package org.connectme.core.userManagement.logic;

import org.connectme.core.userManagement.exceptions.VerificationAttemptNotAllowedException;
import org.connectme.core.userManagement.exceptions.WrongVerificationCodeException;

import java.time.LocalDateTime;
import java.util.Random;

/**
 * Holds all information and progress associated with the two-factor phone number verification via SMS.
 */
public class SmsPhoneNumberVerification {

    /**
     * The maximum amount of verifications a user can attempt sequentially.
     * If the user used all his attempts he must wait for {@value BLOCK_FAILED_ATTEMPT_MINUTES} Minutes before
     * he can try again.
     */
    public static final int MAX_AMOUNT_VERIFICATION_ATTEMPTS = 3;

    /**
     * If the user exceeds {@value MAX_AMOUNT_VERIFICATION_ATTEMPTS} attempts of verifying his phone number
     * he must wait this duration in minutes. This is to limit the verification attempts in total.
     */
    public static final int BLOCK_FAILED_ATTEMPT_MINUTES = 5;

    /** generated verification code for phone number verification */
    private String verificationCode;

    /** amount of verification attempts. Used to limit amount of attempts per time */
    private int verificationAttempts;

    /** last verification attempt. Used to allow only a certain amount of attempts per time */
    private LocalDateTime lastVerificationAttempt;

    /** is registration verified */
    private boolean verified;

    public SmsPhoneNumberVerification() {
        verified = false;
        verificationAttempts = 0;
        lastVerificationAttempt = null;
    }

    /**
     * Checks if a verification attempt is currently allowed. This is not the case, if the user tried to verify his
     * phone number {@value MAX_AMOUNT_VERIFICATION_ATTEMPTS} times unsuccessfully. He has to wait {@value BLOCK_FAILED_ATTEMPT_MINUTES}
     * minutes before he can try again.
     * This method makes sure that this rule is kept.
     * @return true if a verification attempt is allowed at the present moment.
     */
    public boolean isVerificationAttemptCurrentlyAllowed() {
        // TODO: check if there is a pending verification attempt. It must expire before a new one can be opened
        final LocalDateTime now = LocalDateTime.now();
        if(verificationAttempts >= MAX_AMOUNT_VERIFICATION_ATTEMPTS) {
            // CASE: max limit for verification attempts was exceeded
            if(lastVerificationAttempt.plusMinutes(BLOCK_FAILED_ATTEMPT_MINUTES).isBefore(now)) {
                // CASE: enough time has passed, allow more attempts
                verificationAttempts = 0;
                return true;
            } else {
                // CASE: not enough time has passed, prohibit another verification attempt
                return false;
            }
        } else {
            return true;
        }
    }

    /**
     * Randomly generates a verification code
     * @return generated verification code
     * @author Daniel Mehlber
     */
    private String generateVerificationCode() {
        return String.valueOf(new Random().nextInt(99999));
    }

    /**
     * Asserts if passedVerificationCode equals the actual verification code generated by
     * {@link SmsPhoneNumberVerification#generateVerificationCode()}.
     *
     * @param passedVerificationCode the verification code that needs to be checked
     * @throws WrongVerificationCodeException if the assertion failed and the wrong verification code has been passed.
     * @author Daniel Mehlber
     */
    public void checkVerificationCode(String passedVerificationCode) throws WrongVerificationCodeException {
        verificationAttempts++;
        lastVerificationAttempt = LocalDateTime.now();

        if(verificationCode.equals(passedVerificationCode)) {
            verified = true;
        } else {
            verified = false;
            throw new WrongVerificationCodeException();
        }
    }

    /**
     * Starts a new verification attempt after checking if this is allowed at the present moment. If a new attempt
     * is allowed, a verification code will be generated.
     *
     * @throws VerificationAttemptNotAllowedException a new verification attempt is currently not allowed
     * @author Daniel Mehlber
     * @see SmsPhoneNumberVerification#isVerificationAttemptCurrentlyAllowed()
     * @see SmsPhoneNumberVerification#generateVerificationCode()
     */
    public void startVerificationAttempt() throws VerificationAttemptNotAllowedException {
        // check if time window has passed and a new attempt is allowed
        if(isVerificationAttemptCurrentlyAllowed()) {
            // CASE: verification attempt is allowed
            this.verificationCode = generateVerificationCode();

            // TODO: send verification code via SMS (but only if not in testing mode)

        } else {
            // CASE: not enough time has passed, prohibit another verification attempt
            throw new VerificationAttemptNotAllowedException();
        }
    }

    
    public String getVerificationCode() {
        return verificationCode;
    }

    public boolean isVerified() {
        return verified;
    }

    /**
     * Only for testing purposes
     * @param time new time
     */
    public void setLastVerificationAttempt(final LocalDateTime time) {
        lastVerificationAttempt = time;
    }

    public int getMaxVerificationAttempts() {
        return MAX_AMOUNT_VERIFICATION_ATTEMPTS;
    }

    
    public int getBlockedVerificationDurationMinutes() {
        return BLOCK_FAILED_ATTEMPT_MINUTES;
    }

}
